
/////////////////////////////////
Tokenizer
/////////////////////////////////

"text" -> string -> VALUE(STRING)
digits -> number -> VALUE(INT / FLOAT)
symbol -> symbol -> OPERATOR / DELIMITER
name -> name -> VALUE(BOOL) / IDENTIFIER / KEYWORD

/////////////////////////////////
Parser
/////////////////////////////////

VALUE -> VALUE
OPERATOR -> OPERATION_UNARY / OPERATION_BINARY / OPERATION_TERNARY
DELIMITER -> -
IDENTIFIER -> VARIABLE / FUNCTION_CALL
KEYWORD -> CONSTRUCT


    Root
   / \
  O   O
     / \
    O   O
   /   / \
  O   O   Leaf

/////////////////////////////////
Interpreter
/////////////////////////////////

Expression(NODE)
/*
* can be evaluated to return a VALUE
*/
- VALUE(INT, FLOAT, STRING, BOOL, NONE)
- VARIABLE(name: String)
- OPERATION()
- CONSTRUCT***

enum VALUE
/*
* A plain language Value
*/
- INT(Int)
- FLOAT(Float)
- STRING(String)
- BOOL(Bool)
- NONE

VARIABLE
/*
* Evaluated by looking up its associated value into a table
*/


/////////////////////////////////
 TODO?
/////////////////////////////////

Make labels identifier instead of string?
Allow await keyword to return something?
The array implementation is a wrapper for C++ std::vector. Maybe explore if there is a better option?
Check unloading functions safety.


/////////////////////////////////
 Grammar (but not really).
/////////////////////////////////

operand :=      int || float || string ||
                array ||
                parenthesis_expression ||
                function ||

                array_index ||

                array_init ||
                function_call

operation :=    operand (operator operand)? endl

expression :=   operation; ||
                await; ||
                return operation?; ||
                yield operation?; ||

                function name(){} ||

                label "name" ||
                goto operation;
				
				if(){} (else if(){})? (else{})? ||
                for(;;){} ||
                while(){} ||
                do{}while(); ||

